\documentclass[french, 12pt]{article}
\usepackage[a4paper, top=2cm, bottom=2cm, left=2.5cm, right=2.5cm]{geometry}

\usepackage{fancyvrb}

\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{grammar}

\usepackage[indent]{parskip}
\usepackage{amssymb}
\usepackage{calc}
\usepackage{enumitem}
\usepackage{array}
\usepackage{hyperref}
\usepackage{tabularx}
\usepackage{booktabs}

\setlength {\marginparwidth }{2cm}

\usepackage{todonotes}

\pagenumbering{gobble}

\begin{document}

\section*{Syntaxe d'un fichier}
Les commentaires commencent par \texttt{;} et s'étendent jusqu'à la fin de la ligne.

Sections disponibles  :
\begin{description}
      \item[\texttt{.text}] signale le début d'une section d'instructions assembleur.
      \item[\texttt{.data}] signale le début d'une section de déclarations de données.
\end{description}


Chaque instruction ou déclaration peut être localisée par un \emph{label} qui
sera converti en une adresse par l'assembleur. Un label peut être composé des
caractères suivants : \texttt{a}-\texttt{z}, \texttt{A}-\texttt{Z},
\texttt{0}-\texttt{9} ou \texttt{\_}.


On localise une instruction/déclaration à l'aide de la syntaxe :
\begin{verbatim}
label:
      instruction ou déclaration
\end{verbatim}


On note que l'adressage de la mémoire se fait par mots de 32 bits (et pas moins !).
Pour faire appel à des fonctions ou des sections définies dans un autre fichier
on utilise la syntaxe suivante à n'importe quel endroit du fichier :
\verb|.include file|. Dans ce cas, le code du fichier référencé est inséré
à cette position.

Les dossiers utilisés pour la recherche des fichiers à insérer est configurable
via la ligne de commande.%
%
\todo{Quel flag ? À la GCC avec un \texttt{-I} ?}

\section*{Données}

\subsection*{Chaines de caractères}

Les chaines de caractères sont composées des caractères suivants :
\begin{itemize}
      \item Les caractères ASCII affichable (codes $32$ à $126$ inclus).
      \item Le caractère nul noté \verb|\0| (code $0$).
      \item Le caractère d'appel noté \verb|\a| (code $7$).
      \item Le caractère de tabulation noté \verb|\t| (code $9$).
      \item Le caractère de saut de ligne noté \verb|\n| (code $10$).
\end{itemize}

\todo[inline]{Ajouter les caractères permettant de se déplacer dans le terminal ? Quid
      de la gestion de \guillemetleft{}l'écran\guillemetright{} par le simulateur ?
      Le \texttt{\textbackslash{}a} est là pour faire \emph{ding} :)}

Les caractères \texttt{"} et les \texttt{\textbackslash} sont échappés :
\texttt{\textbackslash{}"} pour le guillemet et
\texttt{\textbackslash{}\textbackslash{}} pour la barre oblique inversée.
Chaque caractère est codé sur $8$ bits, le bit de poids fort étant toujours
fixé à $0$.

Puisque les calculs ne peuvent s'opérer que sur des mots de $32$ bits, on encode
les caractères par bloc de $4$, complété si besoin par plusieurs caractères nul,
de la manière suivante :
\begin{equation*}
      \texttt{ab\textbackslash{}nc} \rightsquigarrow \texttt{01100001 01100010 00001010 01100011} \rightsquigarrow \overline{1633815139_{10}}
\end{equation*}

\todo[inline]{Vraiment, Vraiment pas pratique pour la manipulation des chaines...
      Soit faire une stdlib poussée pour manipuler les chaines (concat, substr, getchr, ...)
      Soit faire de l'adressage mémoire par octet : BadBadBad mal au cerveau.}

\subsection*{Entiers}

Les entiers peuvent être donnés dans plusieurs bases :
\begin{itemize}
      \item En base décimale, base par défaut.
      \item En base binaire, lorsque préfixés par \texttt{0b}.
      \item En base hexadécimale, lorsque préfixés par \texttt{0x}.
\end{itemize}

\subsection*{Déclaration des données}

On utilise les notations suivantes pour déclarer des données :
\begin{description}[leftmargin=!, labelwidth=\widthof{\bf \texttt{.string "..."}}]
      \item[\texttt{.ascii "..."}] déclare une chaine de caractère.
            Cette chaine n'est pas forcément terminée par \verb|\0|.
      \item[\texttt{.string "..."}] déclare une chaine de caractère forcément
            terminée par \verb|\0|.
      \item[\texttt{.uint ...}] déclare un entier non signé sur $32$ bits (de $0$ à $2^{32}-1$).
      \item[\texttt{.int ...}] déclare un entier signé sur $32$ bits (de $-2^{31}$ à $2^{31}-1$).
\end{description}

\section*{Instructions}

\subsection*{Registres}

L'assembleur possède $31$ registres de travail : de \texttt{r0} à \texttt{r28},
\texttt{rout}, \texttt{sp}, \texttt{fp}. Les registres suivants ont un sens
particulier :

\begin{description}[leftmargin=!, labelwidth=\widthof{\bf \texttt{rout}}]
      \item[\texttt{r0}] n'est pas modifiable et a comme valeur $0$.
      \item[\texttt{r1}] n'est pas modifiable et a comme valeur $1$.
      \item[\texttt{rout}] est supposé être utilisé afin de stocker la valeur de retour des fonctions.
      \item[\texttt{sp}] a comme valeur la prochaine adresse libre du tas.
      \item[\texttt{fp}] a comme valeur l'adresse du tableau d'activation de la fonction en cours.
\end{description}

\subsection*{Convention d'appel}

La pile est organisée de cette manière lors d'un appel de fonction :
\input{stack}

Les arguments d'une fonction sont données dans les registres \texttt{r20} à \texttt{r28}.
Les registres de \texttt{r15} à \texttt{r28} sont dits \emph{caller-saved} :
une fonction est susceptible d'écraser la valeur de ces registres sans les restaurer.
Les registres de \texttt{r0} à \texttt{r14} sont dits \emph{callee-saved} :
lors de l'appel à une fonction, cette dernière ne doit pas modifier ces registres.

\subsection*{Labels}

Les \emph{labels} ne peuvent être déclarés qu'une seule fois sauf les
\emph{labels} ayant un entier en base décimale comme identifiant. Dans ce cas,
on fait référence au \emph{label} $N$ précédent par $N\texttt{b}$ et au label
suivant par $N\texttt{f}$. La référence à un \emph{label} $N$ de manière directe
n'est pas autorisée.

\subsection*{Format des Sauts}

Lors de saut les formats d'adresse suivants sont autorisés :
\begin{itemize}
      \item Saut à une adresse absolue. L'adresse est donnée sans signe dans
            n'importe quelle base, préfixée de \verb|$|. Exemple :
            \verb|jmp $12| saute à l'adresse $12$ du programme.
      \item Saut à une adresse relative. L'adresse est donnée avec un signe
            (\texttt{+} ou \texttt{-}) dans n'importe quelle base, préfixée de
            \verb|$|. Exemple : \verb|jmp $+12| saute $12$ instruction après,
            \verb|jmp $-12| saute $12$ instruction avant.
      \item Saut à un \emph{label}. L'adresse absolue est calculée par
            l'assembleur. Exemple : \verb|jmp lbl| saute au label \emph{lbl} du
            programme.
\end{itemize}

\todo[inline]{
      Vraiment pas pratique de gérer à la fois les labels ``numériques'' et les
      sauts à des offsets... Pourquoi autoriser les offsets ? C'est bien les
      labels.}

\subsection*{Instructions}

\renewcommand\tabularxcolumn[1]{m{#1}}
\newcolumntype{S}{ p{1cm} }

\subsubsection*{Instructions Logiques}
\noindent
\begin{tabularx}{\textwidth}{cccc S X}
      \toprule
      Instruction  & Destination & \multicolumn{2}{c}{Arguments} &      & Description                       \\
      \midrule
      \texttt{and} & $r1$        & $r2$                          & $r3$ &             & et logique          \\
      \texttt{orr} & $r1$        & $r2$                          & $r3$ &             & ou logique          \\
      \texttt{nor} & $r1$        & $r2$                          & $r3$ &             & non-ou logique      \\
      \texttt{xor} & $r1$        & $r2$                          & $r3$ &             & ou exclusif logique \\
      \texttt{not} & $r1$        & $r2$                          &      &             & non logique         \\
      \bottomrule
\end{tabularx}

\subsubsection*{Instructions Arithmétiques}

\noindent
\begin{tabularx}{\textwidth}{cccc S X}
      \toprule
      Instruction  & Destination & \multicolumn{2}{c}{Arguments} &      & Description                  \\
      \midrule
      \texttt{add} & $r1$        & $r2$                          & $r3$ &             & addition       \\
      \texttt{sub} & $r1$        & $r2$                          & $r3$ &             & soustraction   \\
      \texttt{mul} & $r1$        & $r2$                          & $r3$ &             & multiplication \\
      \texttt{div} & $r1$        & $r2$                          & $r3$ &             & division       \\
      \texttt{neg} & $r1$        & $r2$                          &      &             & négation       \\
      \texttt{inc} & $r1$        & $r2$                          &      &             & incrémente     \\
      \texttt{dec} & $r1$        & $r2$                          &      &             & décrémente     \\
      \bottomrule
\end{tabularx}

\subsubsection*{Décalages}

\noindent
\begin{tabularx}{\textwidth}{ccc S X}
      \toprule
      Instruction  & Destination & Argument &  & Description                    \\
      \midrule
      \texttt{asr} & $r1$        & $r2$     &  & Décalage à droite arithmétique \\
      \texttt{lsr} & $r1$        & $r2$     &  & Décalage à droite logique      \\
      \texttt{lrl} & $r1$        & $r2$     &  & Décalage à gauche              \\
      \bottomrule
\end{tabularx}

\subsubsection*{Opération sur le Tas}

\noindent
\begin{tabularx}{\textwidth}{ccc S X}
      \toprule
      Instruction   & Destination & Argument &  & Description                       \\
      \midrule
      \texttt{push} &             & $r1$     &  & Empile $r1$ sur le tas            \\
      \texttt{pop}  & $r1$        &          &  & Dépile le sommet du tas dans $r1$ \\
      \bottomrule
\end{tabularx}

\subsubsection*{Opération sur la mémoire}

\noindent
\begin{tabularx}{\textwidth}{ccc S X}
      \toprule
      Instruction     & Destination & Argument &   & Description                                            \\
      \midrule
      \texttt{mov}    & $r1$        & $r2$     &   & Copie le registre $r2$ dans $r1$                       \\
      \texttt{load}   & $r1$        & $m$      &   & Copie la valeur de la mémoire à l'adresse $m$ dans $r$ \\
      \texttt{li}     & $r1$        & $i$      &   & Copie la valeur $i$ dans $r1$                          \\
      \texttt{loadi}  & $r1$        & $\$l$    &   & Copie l'adresse associée à $l$ dans $r1$               \\
      \texttt{loadia} &             &          &                                                            \\
      \bottomrule
\end{tabularx}

\end{document}
